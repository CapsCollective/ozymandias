Shader "Instanced/InstancedSurfaceShader" {
    Properties{
        _MainTex("Albedo (RGB)", 2D) = "white" {}
        _Color("Color", Color) = (1,1,1,1)
        _TipColor("Tip Color", Color) = (1,1,1,1)
        _Glossiness("Smoothness", Range(0,1)) = 0.5
        _Metallic("Metallic", Range(0,1)) = 0.0
        _MaskPower("Mask Power", Float) = 0.0
        _MaskSub("Mask Sub", Range(0,1)) = 0.0
        _WindStrength("Wind Strength", Range(0,1)) = 0.0
        _WindSpeed("Wind Speed", Range(0,1)) = 0.0
        _RTSize("RTSize", Float) = 0.0
        _MaskTex("Mask Texture", 2D) = "white" {}
    }
        SubShader{
            Tags{ "RenderType" = "Opaque"  "Queue" = "Geometry" "IgnoreProjector" = "True" }
            LOD 200
            Cull Off

            CGPROGRAM
            // Physically based Standard lighting model
            #pragma surface surf Standard vertex:vert
            #pragma multi_compile_instancing GPU_FRUSTUM_ON__
            #pragma instancing_options procedural:setup


            #include "UnityCG.cginc"

            sampler2D _MainTex;

            struct Input {
                float2 uv_MainTex;
                float3 pos;
            };

        #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED
            StructuredBuffer<float4x4> _MatrixBuffer;
        #endif

            void rotate2D(inout float2 v, float r)
            {
                float s, c;
                sincos(r, s, c);
                v = float2(v.x * c - v.y * s, v.x * s + v.y * c);
            }

            void setup()
            {
            #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED
                float4x4 data = _MatrixBuffer[unity_InstanceID];

                unity_ObjectToWorld = data;
                //unity_ObjectToWorld._11 = data[1][1];
                //unity_ObjectToWorld._12_22_32_42 = float4(0, data.w, 0, 0);
                //unity_ObjectToWorld._13_23_33_43 = float4(0, 0, data.w, 0);
                //unity_ObjectToWorld._14_24_34_44 = float4(data.xyz, 1);
                //unity_WorldToObject = unity_ObjectToWorld;
                //unity_WorldToObject._14_24_34 *= -1;
                //unity_WorldToObject._11_22_33 = 1.0f / unity_WorldToObject._11_22_33;
            #endif
            }

            float3 mod2D289(float3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            float2 mod2D289(float2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            float3 permute(float3 x) { return mod2D289(((x * 34.0) + 1.0) * x); }

            float snoise(float2 v)
            {
                const float4 C = float4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                float2 i = floor(v + dot(v, C.yy));
                float2 x0 = v - i + dot(i, C.xx);
                float2 i1;
                i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
                float4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod2D289(i);
                float3 p = permute(permute(i.y + float3(0.0, i1.y, 1.0)) + i.x + float3(0.0, i1.x, 1.0));
                float3 m = max(0.5 - float3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
                m = m * m;
                m = m * m;
                float3 x = 2.0 * frac(p * C.www) - 1.0;
                float3 h = abs(x) - 0.5;
                float3 ox = floor(x + 0.5);
                float3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
                float3 g;
                g.x = a0.x * x0.x + h.x * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            void Billboard(inout appdata_full v)
            {
                UNITY_SETUP_INSTANCE_ID(v);

                const float3 local = float3(v.vertex.x, v.vertex.y, 0); // this is the quad verts as generated by MakeMesh.cs in the localPos list.
                const float3 offset = v.vertex.xyz - local;

                const float3 upVector = half3(0, 1, 0);
                const float3 forwardVector = UNITY_MATRIX_IT_MV[2].xyz; // camera forward
                const float3 rightVector = normalize(cross(forwardVector, upVector));

                float3 position = 0;
                position += local.x * rightVector;
                position += local.y * upVector;
                position += local.z * forwardVector;

                v.vertex = float4(offset + position, 1);
                //v.normal = forwardVector;
            }


            half _Glossiness;
            half _Metallic;
            fixed4 _Color;
            fixed4 _TipColor;
            half _MaskPower;
            half _MaskSub;
            half _WindStrength;
            half _WindSpeed;
            sampler2D _MaskTex;
            float4 _MaskTex_ST;

            float3 _RTPosition;
            half _RTSize;

            float GetMask(float2 uv) {
                return saturate(pow(uv.y - -_MaskSub, _MaskPower));
            }

            void vert(inout appdata_full v, out Input o) {
                UNITY_INITIALIZE_OUTPUT(Input, o);

                //float4 pos = mul(matrixBuffer[vid], v.vertex);
                //v.vertex = pos;

                //Billboard(v);
                float2 vertexWorldSpace = mul(unity_ObjectToWorld, v.vertex).xz;
                v.vertex.xz += GetMask(v.texcoord) * (snoise(vertexWorldSpace * _Time.x * _WindSpeed) * _WindStrength);

                float3 worldPos = mul(unity_ObjectToWorld, v.vertex);
                float2 RTToWorld = worldPos.xz - _RTPosition.xz;
                RTToWorld /= (_RTSize * 2.0);
                RTToWorld += 0.5;
                //float2 uv_MaskTex = (worldPos.xz + _MaskTex_TexelSize) * _MaskTex_ST.xy + _MaskTex_ST.zw;
                float3 mask = tex2Dlod(_MaskTex, float4(RTToWorld, 0, 0));
                v.vertex.y -= (mask.r + mask.g) * 10;
            }

            void surf(Input IN, inout SurfaceOutputStandard o) {

                //float mask = saturate(pow(IN.uv_MainTex.y - -_MaskSub, _MaskPower));

                fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
                float3 cMask = saturate(c.rgb + (_TipColor.rgb * GetMask(IN.uv_MainTex)));
                o.Albedo = cMask;
                o.Metallic = _Metallic;
                o.Smoothness = _Glossiness;
                clip(c.a - 0.5);
            }
            ENDCG
        }
            FallBack "Diffuse"
}